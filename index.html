<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Venkat Somala - Portfolio</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8IS0tIENlbnRlcmVkIGFuZCBsYXJnZXIgZGlhZ29uYWwgYm9pZCBwb2ludGluZyBsZWZ0IC0tPgogIDxwb2x5Z29uIHBvaW50cz0iNiw4IDI0LDE2IDYsMjQgMTQsMjAgNiwyNiAxNCwyMiIgZmlsbD0iI0RDMTQ0QyIgc3Ryb2tlPSIjQTkyMTIzIiBzdHJva2Utd2lkdGg9IjEiLz4KPC9zdmc+Cg==" type="image/svg+xml">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P:wght@400&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: #2c3e50;
            font-family: 'Press Start 2P', monospace;
            margin: 0;
            cursor: crosshair;
        }
        
        .landing {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: #ddd5c0;
            border: 2px solid #c2baa5;
            border-radius: 8px;
        }
        
        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            font-size: 8px;
            line-height: 1.4;
        }
        
        
        .controls {
            background: transparent;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-size: 6px;
        }
        
        .slider-container {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .slider {
            width: 120px;
            height: 3px;
            background: rgba(0, 0, 0, 0.15);
            outline: none;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .slider::-webkit-slider-track {
            width: 100%;
            height: 3px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 2px;
        }
        
        /* FORCE CLAUDE ORANGE SLIDERS */
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none !important;
            appearance: none !important;
            width: 8px !important;
            height: 8px !important;
            background: #C96442 !important;
            border: none !important;
            border-radius: 50% !important;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            transition: all 0.15s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            background: #d47352 !important;
            transform: scale(1.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        
        .slider::-moz-range-thumb {
            width: 8px;
            height: 8px;
            background: #C96442 !important;
            cursor: pointer;
            border: none;
            border-radius: 50%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        #speed::-webkit-slider-thumb, 
        #separation::-webkit-slider-thumb, 
        #alignment::-webkit-slider-thumb, 
        #cohesion::-webkit-slider-thumb {
            background: #C96442 !important;
        }
        
        #speed::-webkit-slider-thumb:hover, 
        #separation::-webkit-slider-thumb:hover, 
        #alignment::-webkit-slider-thumb:hover, 
        #cohesion::-webkit-slider-thumb:hover {
            background: #d47352 !important;
        }
        
        .title {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            text-align: right;
            font-size: 12px;
        }
        
        .subtitle {
            font-size: 6px;
            color: #9fa8da;
            margin-top: 5px;
        }
        
        button {
            background: #1a1f36;
            color: #e8eaf6;
            border: 1px solid #7986cb;
            border-radius: 4px;
            padding: 5px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 6px;
            cursor: pointer;
            margin: 2px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #7986cb;
            color: #1a1f36;
            box-shadow: 0 0 10px rgba(121, 134, 203, 0.3);
        }
        
.content-section {
    background: white;
    padding: 0;
    font-family: 'Soria', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 40px;
}

.site-header {
    padding: 40px 0;
    border-bottom: 1px solid #e1e1e1;
}

.site-title {
    font-size: 16px;
    font-weight: 600;
    letter-spacing: 2px;
    color: black;
    text-decoration: none;
    margin-bottom: 20px;
    display: block;
    font-family: 'Soria', sans-serif;
}

.nav-menu {
    display: flex;
    gap: 30px;
}

.nav-menu a {
    color: black;
    text-decoration: none;
    font-size: 14px;
    font-weight: normal;
    font-family: 'Soria', sans-serif;
}

.nav-menu a:hover {
    text-decoration: underline;
}

.projects-section {
    padding: 60px 0;
}

.projects-section h2, .contact-section h2 {
    font-size: 24px;
    font-weight: 200;
    margin-bottom: 40px;
    color: black;
    text-align: center;
    font-family: 'Soria', sans-serif;
    letter-spacing: 1.5px;
    /* Updated font weight to 200 for even lighter appearance */
}

.projects-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 30px;
    margin-bottom: 80px;
}

.project-card {
    background: linear-gradient(145deg, #ffffff, #f8f9fa);
    border: 2px solid #e8ecf0;
    border-radius: 16px;
    padding: 0;
    box-shadow: 0 8px 25px rgba(0,0,0,0.08);
    transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    overflow: hidden;
    position: relative;
    display: flex;
    flex-direction: column;
    height: 100%;
}

.project-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #C96442, #e67e52);
    transform: scaleX(0);
    transition: transform 0.3s ease;
}

.project-card:hover::before {
    transform: scaleX(1);
}

.project-card:hover {
    transform: translateY(-8px);
    box-shadow: 0 20px 40px rgba(0,0,0,0.15);
    border-color: #C96442;
}

.project-image {
    width: 100%;
    height: 220px;
    background: #f5f7fa;
    position: relative;
    overflow: hidden;
}

.project-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: all 0.4s ease;
    filter: brightness(0.9) contrast(1.1);
}

.project-card:hover .project-image img {
    transform: scale(1.05);
    filter: brightness(1) contrast(1.2);
}

.project-content {
    padding: 30px;
    display: flex;
    flex-direction: column;
    flex: 1;
}

.project-bottom {
    margin-top: auto;
    padding-top: 20px;
}

.project-card h3 {
    font-size: 22px;
    font-weight: 400;
    margin-bottom: 15px;
    color: #1a202c;
    line-height: 1.3;
    letter-spacing: 0.5px;
    font-family: 'Soria', sans-serif;
}

.project-card p {
    font-size: 16px;
    line-height: 1.6;
    color: #4a5568;
    margin-bottom: 25px;
    font-weight: 400;
    font-family: 'Soria', sans-serif;
}

.tech-stack {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 25px;
}

.tech {
    background: linear-gradient(135deg, #C96442, #d47352);
    color: white;
    padding: 6px 14px;
    border-radius: 25px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 8px rgba(201, 100, 66, 0.3);
    transition: all 0.3s ease;
    font-family: 'Soria', sans-serif;
}

.tech:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(201, 100, 66, 0.4);
}

.project-link {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: linear-gradient(135deg, #C96442, #d47352);
    color: white;
    text-decoration: none;
    font-weight: 600;
    font-size: 12px;
    padding: 10px 20px;
    border-radius: 8px;
    margin-top: 10px;
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 4px 15px rgba(201, 100, 66, 0.3);
    font-family: 'Soria', sans-serif;
}

.project-link:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(201, 100, 66, 0.4);
    background: linear-gradient(135deg, #d47352, #e67e52);
    text-decoration: none;
}

.project-link::after {
    content: 'â†’';
    transition: transform 0.3s ease;
}

.project-link:hover::after {
    transform: translateX(3px);
}

.contact-section {
    text-align: center;
    padding: 40px 0;
    border-top: 1px solid #e1e1e1;
}

.contact-section p {
    font-size: 16px;
    color: #666;
    margin-bottom: 30px;
    font-family: 'Soria', sans-serif;
}

.contact-links {
    display: flex;
    justify-content: center;
    gap: 30px;
}

.contact-links a {
    color: black;
    text-decoration: none;
    font-weight: 500;
    padding: 10px 20px;
    border: 1px solid #e1e1e1;
    border-radius: 6px;
    transition: all 0.2s ease;
    font-family: 'Soria', sans-serif;
}

.contact-links a:hover {
    background: #f8f8f8;
    transform: translateY(-1px);
}
        
@media (max-width: 768px) {
    .projects-grid {
        grid-template-columns: 1fr;
        gap: 20px;
    }
    
    .project-card {
        padding: 20px;
    }
    
    .contact-links {
        flex-direction: column;
        align-items: center;
    }
    
    .container {
        padding: 0 20px;
    }
}
        
        .content-section h2 {
            font-size: 3.5rem;
            font-weight: 200;
            margin-bottom: 60px;
            text-align: center;
            letter-spacing: 1.5px;
            font-family: 'Inter', sans-serif;
        }
        
        .education-section {
            background: #ffffff;
            padding: 100px 0;
            color: #1a202c;
            border-top: 1px solid #e5e7eb;
        }
        
        .education-section h2 {
            color: #1a202c;
        }
        
        .degree-subtitle {
            font-size: 1.1rem;
            color: #6b7280;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
        }
        
        .graduation {
            font-size: 1.1rem;
            color: #9ca3af;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
            text-align: right;
        }
        
        .portfolio-section h2, .interests-section h2 {
            color: #1a202c;
        }
        
        .education-content {
            display: flex;
            flex-direction: column;
            gap: 50px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .education-text {
            width: 100%;
        }
        
        .education-image {
            width: 100%;
        }
        
        .education-image img {
            width: 100%;
            height: 350px;
            object-fit: cover;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .degree-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 30px;
        }
        
        .degree-left {
            flex: 1;
        }
        
        .degree-info h3 {
            font-size: 2rem;
            font-weight: 500;
            color: #1a202c;
            margin-bottom: 8px;
            font-family: 'Inter', sans-serif;
        }
        
        .degree-info h4 {
            font-size: 2rem;
            font-weight: 300;
            color: #4a5568;
            margin-bottom: 20px;
            font-family: 'Inter', sans-serif;
        }
        
        .minors {
            font-size: 1.4rem;
            color: #6b7280;
            font-weight: 300;
            font-family: 'Inter', sans-serif;
            margin-bottom: 15px;
        }
        
        .capstone h4 {
            font-size: 1.8rem;
            font-weight: 400;
            color: #1a202c;
            margin-bottom: 20px;
            font-family: 'Inter', sans-serif;
        }
        
        .capstone p {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
            margin-bottom: 16px;
            font-weight: 300;
            font-family: 'Inter', sans-serif;
        }
        
        .findings {
            font-style: italic;
            color: #1a202c;
            font-weight: 400;
            font-size: 1.1rem;
            font-family: 'Inter', sans-serif;
        }
        
        .portfolio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 32px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .project {
            background: #ffffff;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .project:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }
        
        .project h4 {
            font-size: 1.5rem;
            font-weight: 400;
            color: #1a202c;
            margin-bottom: 16px;
            letter-spacing: 0.5px;
            font-family: 'Inter', sans-serif;
        }
        
        .project p {
            font-size: 1rem;
            color: #4a5568;
            line-height: 1.6;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
        }
        
        .interests-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 24px;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .interest-category {
            background: #ffffff;
            border-radius: 16px;
            padding: 32px;
            text-align: left;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }
        
        .interest-category:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        }
        
        .interest-category h4 {
            font-size: 1.25rem;
            font-weight: 400;
            color: #1a202c;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Inter', sans-serif;
        }
        
        .interest-category p {
            font-size: 1rem;
            color: #4a5568;
            line-height: 1.6;
            margin-bottom: 12px;
            font-weight: 400;
            font-family: 'Inter', sans-serif;
        }
        
        .interest-icon {
            font-size: 1.5rem;
        }
        
        @media (max-width: 768px) {
            .section-container {
                padding: 0 20px;
            }
            
            .content-section {
                padding: 80px 0;
            }
            
            .content-section h2 {
                font-size: 2.5rem;
                margin-bottom: 40px;
            }
            
            .education-content {
                flex-direction: column;
                gap: 32px;
            }
            
            .portfolio-grid {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .interests-content {
                grid-template-columns: 1fr;
            }
            
            .degree-info h3 {
                font-size: 2rem;
            }
            
            .degree-info h4 {
                font-size: 1.5rem;
            }
            
            .project {
                padding: 24px;
            }
            
            .interest-category {
                padding: 24px;
            }
        }
        
    </style>
</head>
<body>
    <div class="landing">
        <canvas id="canvas"></canvas>
        
        <div class="ui">
            
            <div class="controls">
                <div class="slider-container">
                    <span>Speed:</span>
                    <input type="range" class="slider" id="speed" min="10" max="200" value="100">
                </div>
                
                <div class="slider-container">
                    <span>Separation:</span>
                    <input type="range" class="slider" id="separation" min="0" max="100" value="25">
                </div>
                
                <div class="slider-container">
                    <span>Alignment:</span>
                    <input type="range" class="slider" id="alignment" min="0" max="100" value="30">
                </div>
                
                <div class="slider-container">
                    <span>Cohesion:</span>
                    <input type="range" class="slider" id="cohesion" min="0" max="100" value="25">
                </div>
                
                <button onclick="swarm.reset()">RESET</button>
                <button onclick="swarm.clearBarriers()">CLEAR</button>
            </div>
        </div>
        
        
    </div>
    
    <section class="content-section">
    <div class="container">
        <header class="site-header">
            <a href="#" class="site-title">VENKAT SOMALA</a>
            <nav class="nav-menu">
                <a href="#projects">Projects</a>
                <a href="#education">Education</a>
                <a href="#contact">Contact</a>
            </nav>
        </header>
        
        <div class="projects-section">
            <h2>Projects</h2>
            <div class="projects-grid">
                <div class="project-card">
                    <div class="project-image">
                        <img src="https://vsomala.github.io/assets/img/airbnb.webp" alt="Airbnb Price Prediction" loading="lazy">
                    </div>
                    <div class="project-content">
                        <h3>Modeling Airbnb Prices</h3>
                        <p>Predicting Airbnb Prices Using Machine Learning. Built predictive models using KNN and Lasso algorithms to estimate property prices based on features and location.</p>
                        <div class="project-bottom">
                            <div class="tech-stack">
                                <span class="tech">KNN</span>
                                <span class="tech">Lasso</span>
                                <span class="tech">Scikit-learn</span>
                            </div>
                            <a href="https://vsomala.github.io/Predicting-Airbnb-Prices/" target="_blank" rel="noopener noreferrer" class="project-link">View Project</a>
                        </div>
                    </div>
                </div>
                
                <div class="project-card">
                    <div class="project-image">
                        <img src="https://vsomala.github.io/assets/img/song_genre.png" alt="Spotify Genre Prediction" loading="lazy">
                    </div>
                    <div class="project-content">
                        <h3>Predicting Spotify Song Genre</h3>
                        <p>Can we predict a song's genre based on its acoustic properties and the year it was made? Using machine learning to classify music genres.</p>
                        <div class="project-bottom">
                            <div class="tech-stack">
                                <span class="tech">Classification</span>
                                <span class="tech">Audio Analysis</span>
                                <span class="tech">Spotify API</span>
                            </div>
                            <a href="https://vsomala.github.io/Predicting-Spotify-Song-Genre/" target="_blank" rel="noopener noreferrer" class="project-link">View Project</a>
                        </div>
                    </div>
                </div>
                
                <div class="project-card">
                    <div class="project-image">
                        <img src="https://vsomala.github.io/assets/img/joy_division.jpg" alt="Spotify Popularity Prediction" loading="lazy">
                    </div>
                    <div class="project-content">
                        <h3>Predicting Spotify Song Popularity</h3>
                        <p>What makes a song popular? Analyzing 10,000 songs to predict popularity based only on acoustic properties and music features.</p>
                        <div class="project-bottom">
                            <div class="tech-stack">
                                <span class="tech">Regression</span>
                                <span class="tech">Feature Engineering</span>
                                <span class="tech">Data Viz</span>
                            </div>
                            <a href="https://vsomala.github.io/Predicting-Spotify-Song-Popularity/" target="_blank" rel="noopener noreferrer" class="project-link">View Project</a>
                        </div>
                    </div>
                </div>
                
                <div class="project-card">
                    <div class="project-image">
                        <img src="https://vsomala.github.io/assets/img/fake.jpg" alt="Fake News Detection" loading="lazy">
                    </div>
                    <div class="project-content">
                        <h3>Flagging Fake News</h3>
                        <p>Built an algorithm that automatically flags incoming news stories as 'fake' or 'real' using natural language processing and sentiment analysis.</p>
                        <div class="project-bottom">
                            <div class="tech-stack">
                                <span class="tech">NLP</span>
                                <span class="tech">Sentiment Analysis</span>
                                <span class="tech">LASSO</span>
                            </div>
                            <a href="https://vsomala.github.io/Flagging-Fake-News/" target="_blank" rel="noopener noreferrer" class="project-link">View Project</a>
                        </div>
                    </div>
                </div>
                
                <div class="project-card">
                    <div class="project-image">
                        <img src="https://vsomala.github.io/assets/img/candy.jpg" alt="Candy Clustering" loading="lazy">
                    </div>
                    <div class="project-content">
                        <h3>Clustering Candies</h3>
                        <p>Using Machine Learning Algorithms to Cluster Similar Candies based on their nutritional properties and consumer preferences.</p>
                        <div class="project-bottom">
                            <div class="tech-stack">
                                <span class="tech">K-Means</span>
                                <span class="tech">Clustering</span>
                                <span class="tech">Data Viz</span>
                            </div>
                            <a href="https://vsomala.github.io/Clustering-Candies/" target="_blank" rel="noopener noreferrer" class="project-link">View Project</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="education-section" id="education">
            <h2>Education</h2>
            <div class="education-content">
                <div class="education-text">
                    <div class="degree-info">
                        <div class="degree-header">
                            <div class="degree-left">
                                <h3>Macalester College</h3>
                                <div class="degree-subtitle">Economics w/ Minors in Statistics and Philosophy</div>
                            </div>
                            <div class="graduation">2016 - 2020</div>
                        </div>
                    </div>
                    
                    <div class="capstone">
                        <h4>Capstone Research</h4>
                        <p>Studied macroeconomic impacts of New Member States joining the EU in the 2000s, focusing on export dependence, industry specialization, and Global Value Chain participation. Found that New Member States became more export-dependent on EU markets and shifted towards labor-intensive industries, increasing their vulnerability to global economic shocks.</p>
                    </div>
                </div>
                
                <div class="education-image">
                    <img src="https://www.macalester.edu/wp-content/uploads/2020/02/admissions-admitted-hero-e1648069978971.jpg" alt="Macalester College" loading="lazy">
                </div>
            </div>
        </div>
        
        <div class="contact-section">
            <h2>Contact</h2>
            <p>Feel free to get in touch to chat!</p>
            <div class="contact-links">
                <a href="mailto:lvsomala@gmail.com.">Email</a>
                <a href="https://www.linkedin.com/in/lakshmi-venkat-somala-135278105/" target="_blank">LinkedIn</a>
            </div>
        </div>
    </div>
</section>

    <script>
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            
            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }
            
            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            }
            
            mult(n) {
                this.x *= n;
                this.y *= n;
                return this;
            }
            
            div(n) {
                if (n !== 0) {
                    this.x /= n;
                    this.y /= n;
                }
                return this;
            }
            
            mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            
            normalize() {
                const m = this.mag();
                if (m > 0) {
                    this.div(m);
                }
                return this;
            }
            
            limit(max) {
                if (this.mag() > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }
            
            copy() {
                return new Vector2(this.x, this.y);
            }
            
            static sub(v1, v2) {
                return new Vector2(v1.x - v2.x, v1.y - v2.y);
            }
            
            static add(v1, v2) {
                return new Vector2(v1.x + v2.x, v1.y + v2.y);
            }
            
            static dist(v1, v2) {
                return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2);
            }
            
            static dot(v1, v2) {
                return v1.x * v2.x + v1.y * v2.y;
            }
        }
        
        class Letter {
            constructor(char, targetX, targetY) {
                this.char = char;
                
                // Initialize letters off-screen to fly in
                const buffer = 100;
                let x, y;
                const side = Math.floor(Math.random() * 4);

                switch (side) {
                    case 0: // Top
                        x = Math.random() * canvas.width;
                        y = -buffer;
                        break;
                    case 1: // Right
                        x = canvas.width + buffer;
                        y = Math.random() * canvas.height;
                        break;
                    case 2: // Bottom
                        x = Math.random() * canvas.width;
                        y = canvas.height + buffer;
                        break;
                    case 3: // Left
                        x = -buffer;
                        y = Math.random() * canvas.height;
                        break;
                }
                this.position = new Vector2(x, y);

                this.velocity = new Vector2(
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 6
                );
                this.acceleration = new Vector2(0, 0);
                this.target = new Vector2(targetX, targetY);
                
                this.maxSpeed = 2.5;
                this.maxForce = 0.04;
                this.size = 10; // Even smaller letters
                this.settled = false;
                this.settlementRadius = 8;
                
                // Animation timing - longer wandering phase
                this.flyTime = 5000 + Math.random() * 3000; // 5-8 seconds of flying
                this.startTime = Date.now() + Math.random() * 2000; // More staggered start
                this.transitionTime = 2000; // 2 seconds for gradual transition
            }
            
            update(boids) {
                const currentTime = Date.now();
                const elapsed = currentTime - this.startTime;
                
                if (elapsed < 0) return; // Haven't started yet
                
                if (!this.settled) {
                    // Check distance to target position
                    const distToTarget = Vector2.dist(this.position, this.target);
                    const attractionRadius = 200; // Larger attraction zone
                    
                    if (distToTarget < attractionRadius) {
                        // Close to target - strong attraction to final position
                        const targetForce = this.seek(this.target);
                        const attractionStrength = (attractionRadius - distToTarget) / attractionRadius;
                        targetForce.mult(attractionStrength * 5); // Much stronger attraction
                        this.acceleration.add(targetForce);
                        
                        // Settle if very close
                        if (distToTarget < this.settlementRadius) {
                            this.settled = true;
                            this.position = this.target.copy();
                            this.velocity.mult(0);
                            return;
                        }
                    } else {
                        // Far from target - follow boid swarms
                        const flockForce = this.followBoids(boids);
                        this.acceleration.add(flockForce);
                        
                        // Add some wandering for natural movement
                        const wander = this.wander();
                        wander.mult(0.3);
                        this.acceleration.add(wander);
                    }
                }
                
                if (!this.settled) {
                    // Update velocity and position
                    this.velocity.add(this.acceleration);
                    this.velocity.limit(this.maxSpeed);
                    this.position.add(this.velocity);
                    
                    // Wrap around screen while flying
                    this.wrap();
                }
                
                // Reset acceleration
                this.acceleration.mult(0);
            }
            
            seek(target) {
                const desired = Vector2.sub(target, this.position);
                desired.normalize();
                desired.mult(this.maxSpeed);
                
                const steer = Vector2.sub(desired, this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }
            
            followBoids(boids) {
                // Find nearby boids and follow their general direction
                let averagePosition = new Vector2(0, 0);
                let averageVelocity = new Vector2(0, 0);
                let nearbyCount = 0;
                const detectionRadius = 80;
                
                for (const boid of boids) {
                    const distance = Vector2.dist(this.position, boid.position);
                    if (distance < detectionRadius) {
                        averagePosition.add(boid.position);
                        averageVelocity.add(boid.velocity);
                        nearbyCount++;
                    }
                }
                
                let flockForce = new Vector2(0, 0);
                
                if (nearbyCount > 0) {
                    // Move towards the average position (cohesion)
                    averagePosition.div(nearbyCount);
                    const cohesion = this.seek(averagePosition);
                    cohesion.mult(0.5);
                    
                    // Match average velocity (alignment) 
                    averageVelocity.div(nearbyCount);
                    averageVelocity.normalize();
                    averageVelocity.mult(this.maxSpeed);
                    const alignment = Vector2.sub(averageVelocity, this.velocity);
                    alignment.limit(this.maxForce);
                    alignment.mult(0.3);
                    
                    flockForce.add(cohesion);
                    flockForce.add(alignment);
                }
                
                return flockForce;
            }
            
            wander() {
                // Simple wandering for natural movement
                if (!this.wanderAngle) {
                    this.wanderAngle = Math.random() * Math.PI * 2;
                }
                
                this.wanderAngle += (Math.random() - 0.5) * 0.2;
                
                return new Vector2(
                    Math.cos(this.wanderAngle) * 0.05,
                    Math.sin(this.wanderAngle) * 0.05
                );
            }
            
            wrap() {
                if (this.position.x < 0) this.position.x = canvas.width;
                if (this.position.x > canvas.width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = canvas.height;
                if (this.position.y > canvas.height) this.position.y = 0;
            }
            
            draw(ctx) {
                const currentTime = Date.now();
                const elapsed = currentTime - this.startTime;
                
                if (elapsed < 0) return; // Haven't started yet
                
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                
                // Add some rotation if still flying
                if (!this.settled) {
                    const angle = Math.atan2(this.velocity.y, this.velocity.x);
                    ctx.rotate(angle * 0.1); // Subtle rotation
                }
                
                // Set font and style
                ctx.fillStyle = this.settled ? '#C96442' : '#3498db';
                ctx.font = `${this.size}px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Add glow effect while flying
                if (!this.settled) {
                    ctx.shadowColor = '#C96442';
                    ctx.shadowBlur = 8;
                }
                
                ctx.fillText(this.char, 0, 0);
                
                ctx.restore();
            }
        }
        
        class Boid {
            constructor(x, y) {
                this.position = new Vector2(x, y);

                // Give boids an initial velocity towards the center of the screen
                // This makes them fly in from their off-screen starting positions
                const center = new Vector2(canvas.width / 2, canvas.height / 2);
                const target = new Vector2(
                    center.x + (Math.random() - 0.5) * (canvas.width * 0.4), // Target a spot in the middle 40% of the screen
                    center.y + (Math.random() - 0.5) * (canvas.height * 0.4)
                );

                this.velocity = Vector2.sub(target, this.position);
                this.velocity.normalize();
                this.velocity.mult(Math.random() * 2 + 2); // Initial speed between 2 and 4
                
                this.acceleration = new Vector2(0, 0);
                
                this.maxSpeed = 2 + Math.random() * 1.5;
                this.maxForce = 0.03;
                this.size = 2 + Math.random() * 2;
                
                // Color based on initial velocity
                const hue = (Math.atan2(this.velocity.y, this.velocity.x) + Math.PI) / (2 * Math.PI);
                this.hue = hue;
                
                this.trail = [];
                this.trailLength = 8;
                
            }
            
            update() {
                // Update velocity
                this.velocity.add(this.acceleration);
                this.velocity.limit(this.maxSpeed * swarm.speedMultiplier);
                
                // Update position
                this.position.add(this.velocity);
                
                // Update trail for individual boid tails
                this.trail.push(this.position.copy());
                if (this.trail.length > this.trailLength) {
                    this.trail.shift();
                }
                
                // Reset acceleration
                this.acceleration.mult(0);
                
                // Wrap around screen
                this.wrap();
            }
            
            wrap() {
                if (this.position.x < 0) this.position.x = canvas.width;
                if (this.position.x > canvas.width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = canvas.height;
                if (this.position.y > canvas.height) this.position.y = 0;
            }
            
            flock(boids) {
                const sep = this.separate(boids);
                const ali = this.align(boids);
                const coh = this.cohesion(boids);
                
                // Apply weights
                sep.mult(swarm.separationWeight);
                ali.mult(swarm.alignmentWeight);
                coh.mult(swarm.cohesionWeight);
                
                // Apply forces
                this.acceleration.add(sep);
                this.acceleration.add(ali);
                this.acceleration.add(coh);
            }
            
            separate(boids) {
                const desiredSeparation = 25;
                const steer = new Vector2(0, 0);
                let count = 0;
                
                for (const other of boids) {
                    const d = Vector2.dist(this.position, other.position);
                    if (d > 0 && d < desiredSeparation) {
                        const diff = Vector2.sub(this.position, other.position);
                        diff.normalize();
                        diff.div(d); // Weight by distance
                        steer.add(diff);
                        count++;
                    }
                }
                
                if (count > 0) {
                    steer.div(count);
                    steer.normalize();
                    steer.mult(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.limit(this.maxForce);
                }
                
                return steer;
            }
            
            align(boids) {
                const neighborDist = 50;
                const sum = new Vector2(0, 0);
                let count = 0;
                
                for (const other of boids) {
                    const d = Vector2.dist(this.position, other.position);
                    if (d > 0 && d < neighborDist) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.div(count);
                    sum.normalize();
                    sum.mult(this.maxSpeed);
                    const steer = Vector2.sub(sum, this.velocity);
                    steer.limit(this.maxForce);
                    return steer;
                }
                
                return new Vector2(0, 0);
            }
            
            cohesion(boids) {
                const neighborDist = 50;
                const sum = new Vector2(0, 0);
                let count = 0;
                
                for (const other of boids) {
                    const d = Vector2.dist(this.position, other.position);
                    if (d > 0 && d < neighborDist) {
                        sum.add(other.position);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.div(count);
                    return this.seek(sum);
                }
                
                return new Vector2(0, 0);
            }
            
            seek(target) {
                const desired = Vector2.sub(target, this.position);
                desired.normalize();
                desired.mult(this.maxSpeed);
                
                const steer = Vector2.sub(desired, this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }
            
            flee(target) {
                const desired = Vector2.sub(this.position, target);
                desired.normalize();
                desired.mult(this.maxSpeed);
                
                const steer = Vector2.sub(desired, this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }
            
            avoidBarriers(barriers) {
                const avoidanceForce = new Vector2(0, 0);
                const avoidanceRadius = 40; // Increased detection radius
                
                for (const barrier of barriers) {
                    const distToBarrier = this.distanceToLineSegment(barrier.start, barrier.end);
                    
                    if (distToBarrier < avoidanceRadius) {
                        const avoidDir = this.getAvoidanceDirection(barrier.start, barrier.end);
                        const strength = (avoidanceRadius - distToBarrier) / avoidanceRadius;
                        avoidDir.mult(strength * 2.0); // Stronger avoidance
                        avoidanceForce.add(avoidDir);
                    }
                }
                
                if (avoidanceForce.mag() > 0) {
                    avoidanceForce.normalize();
                    avoidanceForce.mult(this.maxSpeed);
                    const steer = Vector2.sub(avoidanceForce, this.velocity);
                    steer.limit(this.maxForce * 5); // Much stronger steering force
                    this.acceleration.add(steer);
                }
            }
            
            distanceToLineSegment(start, end) {
                const A = this.position.x - start.x;
                const B = this.position.y - start.y;
                const C = end.x - start.x;
                const D = end.y - start.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                const param = Math.max(0, Math.min(1, dot / lenSq));
                
                const xx = start.x + param * C;
                const yy = start.y + param * D;
                
                const dx = this.position.x - xx;
                const dy = this.position.y - yy;
                
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            getAvoidanceDirection(start, end) {
                const lineDir = Vector2.sub(end, start).normalize();
                const toPoint = Vector2.sub(this.position, start);
                const projection = lineDir.copy().mult(Vector2.dot(toPoint, lineDir));
                const perpendicular = Vector2.sub(toPoint, projection);
                
                if (perpendicular.mag() > 0) {
                    return perpendicular.normalize();
                } else {
                    return new Vector2(-lineDir.y, lineDir.x);
                }
            }
            
            draw(ctx) {
                const angle = Math.atan2(this.velocity.y, this.velocity.x);
                
                // Draw individual boid trail/tail
                if (this.trail.length > 1) {
                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = i / this.trail.length;
                        const size = alpha * this.size * 0.5;
                        ctx.fillStyle = `hsla(${this.hue * 360 + 30}, 75%, 35%, ${alpha * 0.8})`;
                        ctx.fillRect(
                            Math.floor(this.trail[i].x - size/2),
                            Math.floor(this.trail[i].y - size/2),
                            Math.floor(size),
                            Math.floor(size)
                        );
                    }
                }
                
                // Draw boid with elegant colors
                ctx.fillStyle = `hsl(${this.hue * 360 + 30}, 75%, 40%)`;
                
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(angle);
                
                // Draw triangle
                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(-this.size, -this.size * 0.7);
                ctx.lineTo(-this.size * 0.5, 0);
                ctx.lineTo(-this.size, this.size * 0.7);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        class SwarmSystem {
            constructor() {
                this.boids = [];
                this.boidCount = 220;
                this.paused = false;
                this.showTrails = false;
                
                // Improved default flocking weights for better cohesion
                this.separationWeight = 2.5;
                this.alignmentWeight = 3.0;
                this.cohesionWeight = 2.5;
                this.speedMultiplier = 1.0;
                
                // Letter animation
                this.letters = [];
                this.initializeLetters();
                
                // Drawing system
                this.barriers = [];
                this.isDrawing = false;
                this.mousePos = new Vector2(0, 0);
                this.lastMousePos = new Vector2(0, 0);
                this.showTrails = true; // Always show individual boid tails
                
                this.setupEventListeners();
                // Boids will be initialized after canvas is resized
            }
            
            initializeBoids() {
                this.boids = []; // Clear existing boids
                const totalDuration = 3000; // 3 seconds for all boids to enter
                const buffer = 50;

                for (let i = 0; i < this.boidCount; i++) {
                    const delay = (i / this.boidCount) * totalDuration; // Stagger creation

                    setTimeout(() => {
                        let x, y;
                        const side = Math.floor(Math.random() * 4);

                        switch (side) {
                            case 0: // Top
                                x = Math.random() * canvas.width;
                                y = -buffer;
                                break;
                            case 1: // Right
                                x = canvas.width + buffer;
                                y = Math.random() * canvas.height;
                                break;
                            case 2: // Bottom
                                x = Math.random() * canvas.width;
                                y = canvas.height + buffer;
                                break;
                            case 3: // Left
                                x = -buffer;
                                y = Math.random() * canvas.height;
                                break;
                        }

                        if (canvas.width > 0 && canvas.height > 0) {
                           this.boids.push(new Boid(x, y));
                        }

                    }, delay);
                }
            }
            
            initializeLetters() {
                const name = 'VENKAT SOMALA';
                const startX = canvas.width - 300; // Bottom right area
                const startY = canvas.height - 50;
                const letterSpacing = 22;
                
                this.letters = [];
                for (let i = 0; i < name.length; i++) {
                    const char = name[i];
                    if (char === ' ') continue; // Skip spaces in animation
                    const targetX = startX + (i * letterSpacing);
                    const targetY = startY;
                    
                    this.letters.push(new Letter(char, targetX, targetY));
                }
            }
            
            setupEventListeners() {
                // Mouse tracking and drawing
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    this.lastMousePos = this.mousePos.copy();
                    this.mousePos.x = e.clientX - rect.left;
                    this.mousePos.y = e.clientY - rect.top;
                    
                    if (this.isDrawing) {
                        this.addBarrierSegment();
                    }
                });
                
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click
                        this.isDrawing = true;
                        this.addBarrierSegment();
                    } else if (e.button === 2) { // Right click
                        this.eraseBarriers();
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    this.isDrawing = false;
                });
                
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.paused = !this.paused;
                    }
                });
                
                // Sliders
                document.getElementById('speed').addEventListener('input', (e) => {
                    this.speedMultiplier = e.target.value / 100;
                });
                
                document.getElementById('separation').addEventListener('input', (e) => {
                    this.separationWeight = e.target.value / 10;
                });
                
                document.getElementById('alignment').addEventListener('input', (e) => {
                    this.alignmentWeight = e.target.value / 10;
                });
                
                document.getElementById('cohesion').addEventListener('input', (e) => {
                    this.cohesionWeight = e.target.value / 10;
                });
            }
            
            update() {
                if (this.paused) return;
                
                for (const boid of this.boids) {
                    boid.flock(this.boids);
                    boid.avoidBarriers(this.barriers);
                    boid.update();
                }
                
                // Update letters (pass boids for flocking behavior)
                for (const letter of this.letters) {
                    letter.update(this.boids);
                }
            }
            
            draw(ctx) {
                // Clear canvas completely (no permanent background trails)
                ctx.fillStyle = '#ddd5c0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw barriers with smoother lines
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (this.barriers.length > 0) {
                    // Group consecutive barriers into smooth paths
                    let currentPath = [];
                    
                    for (let i = 0; i < this.barriers.length; i++) {
                        const barrier = this.barriers[i];
                        
                        if (currentPath.length === 0) {
                            currentPath.push(barrier.start, barrier.end);
                        } else {
                            // Check if this barrier connects to the previous one
                            const lastPoint = currentPath[currentPath.length - 1];
                            const distance = Vector2.dist(lastPoint, barrier.start);
                            
                            if (distance < 10) {
                                // Connected, add to current path
                                currentPath.push(barrier.end);
                            } else {
                                // Not connected, draw current path and start new one
                                this.drawSmoothPath(ctx, currentPath);
                                currentPath = [barrier.start, barrier.end];
                            }
                        }
                    }
                    
                    // Draw the final path
                    if (currentPath.length > 0) {
                        this.drawSmoothPath(ctx, currentPath);
                    }
                }
                
                // Draw boids
                for (const boid of this.boids) {
                    boid.draw(ctx);
                }
                
                // Draw letters
                for (const letter of this.letters) {
                    letter.draw(ctx);
                }
            }
            
            
            
            reset() {
                // Only reset barriers and parameters, keep boids in current positions
                this.barriers = [];
                
                // Reset letters animation
                this.initializeLetters();
                
                // Reset slider values to improved defaults
                document.getElementById('speed').value = 100;
                document.getElementById('separation').value = 25;
                document.getElementById('alignment').value = 30;
                document.getElementById('cohesion').value = 25;
                
                // Reset weights to improved defaults
                this.speedMultiplier = 1.0;
                this.separationWeight = 2.5;
                this.alignmentWeight = 3.0;
                this.cohesionWeight = 2.5;
            }
            
            
            addBarrierSegment() {
                if (this.lastMousePos.x !== 0 && this.lastMousePos.y !== 0) {
                    // Only add segment if mouse moved enough for smoother lines
                    const distance = Vector2.dist(this.lastMousePos, this.mousePos);
                    if (distance > 5) {
                        this.barriers.push({
                            start: this.lastMousePos.copy(),
                            end: this.mousePos.copy()
                        });
                    }
                }
            }
            
            eraseBarriers() {
                // Remove barriers near mouse position
                this.barriers = this.barriers.filter(barrier => {
                    const dist1 = Vector2.dist(barrier.start, this.mousePos);
                    const dist2 = Vector2.dist(barrier.end, this.mousePos);
                    return dist1 > 20 && dist2 > 20;
                });
            }
            
            clearBarriers() {
                this.barriers = [];
            }
            
            drawSmoothPath(ctx, points) {
                if (points.length < 2) return;
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                if (points.length === 2) {
                    // Simple line for just two points
                    ctx.lineTo(points[1].x, points[1].y);
                } else {
                    // Use quadratic curves for smooth lines
                    for (let i = 1; i < points.length - 1; i++) {
                        const midX = (points[i].x + points[i + 1].x) / 2;
                        const midY = (points[i].y + points[i + 1].y) / 2;
                        ctx.quadraticCurveTo(points[i].x, points[i].y, midX, midY);
                    }
                    // Draw to the last point
                    ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
                }
                
                ctx.stroke();
            }
        }
        
        // Initialize
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let swarm = null;
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            console.log('Canvas resized to:', canvas.width, 'x', canvas.height);
            if (swarm && canvas.width > 0 && canvas.height > 0) {
                swarm.initializeBoids();
                swarm.initializeLetters();
                console.log('Initialized', swarm.boids.length, 'boids');
            }
        }
        
        window.addEventListener('resize', resize);
        resize();
        
        swarm = new SwarmSystem();
        
        // Ensure boids are initialized after canvas is properly sized
        setTimeout(() => {
            swarm.initializeBoids();
        }, 100);
        
        // Animation loop
        function animate() {
            swarm.update();
            swarm.draw(ctx);
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>